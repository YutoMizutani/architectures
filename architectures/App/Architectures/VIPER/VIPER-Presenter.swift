//
//  VIPER-Presenter.swift
//  architectures
//
//  Created YutoMizutani on 2018/06/06.
//  Copyright © 2018 Yuto Mizutani. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

/*
 
 Presenter
     Presenterの仕事は、VIPER Moduleのメイン部品との橋渡しっぽいことです。
     ある意味、ViewとInteractorへ要求中の返値から入力イベントを受け取りますが、一方で、Interactorからデータ構造を受け取り、データ上にViewロジックを適用し、コンテンツの準備をし、最後にViewに何を表示するか教えます。

 [iOS Project Architecture : Using VIPER [和訳]](https://qiita.com/YKEI_mrn/items/67735d8ebc9a83fffd29)より

 */

import UIKit

class VIPERPresenter {

    weak private var view: VIPERViewProtocol?
    var interactor: VIPERInteractorInputProtocol?
    private let router: VIPERWireframeProtocol

    let from: UserList = .watanabe
    let to: UserList = .takahashi
    let amount: Int = Assets.amount

    init(interface: VIPERViewProtocol, interactor: VIPERInteractorInputProtocol?, router: VIPERWireframeProtocol) {
        self.view = interface
        self.interactor = interactor
        self.router = router
    }

}

extension VIPERPresenter: VIPERPresenterProtocol {
    func fetch() {
        do {
            if let interactor = self.interactor {
                let entities = try interactor.fetchEntity()
                let users = try self.translate(entities)
                self.updateBalance(users)
            }
        }catch let e {
            self.throwError(e)
        }
    }

    func transfer() {
        do {
            if let interactor = self.interactor {
                let entities = try interactor.fetchEntity()
                let users = try self.translate(entities)
                let result = (
                    to: try interactor.credit(users.to, amount: self.amount),
                    from: try interactor.debit(users.from, amount: self.amount)
                )
                interactor.commit([result.from, result.to])
                self.updateBalance(result)
            }
        }catch let e {
            self.throwError(e)
        }
    }

    func reset() {
        if let interactor = self.interactor {
            let result = interactor.reset([self.from, self.to].map{ VIPEREntity(user: $0, balance: 0) })
            do {
                let users = try self.translate(result)
                interactor.commit(result)
                self.updateBalance(users)
            }catch let e {
                self.throwError(e)
            }
        }
    }
}

extension VIPERPresenter {
    private func translate(_ entities: [VIPEREntity]) throws -> (from: VIPEREntity, to: VIPEREntity) {
        let userEntities = [self.from, self.to].map{ user in entities.filter{ $0.user == user }.first }
        if (userEntities.filter{ $0 == nil }.count) > 0 {
            throw ErrorTransfer.userNotFound
        }
        return (userEntities[0]!, userEntities[1]!)
    }
}

extension VIPERPresenter: VIPERInteractorOutputProtocol {
    func updateBalance(_ users: (from: VIPEREntity, to: VIPEREntity)) {
        self.view?.updateLabel(users)
    }

    func throwError(_ error: Error) {
        self.view?.presentAlert(error: error)
    }
}
