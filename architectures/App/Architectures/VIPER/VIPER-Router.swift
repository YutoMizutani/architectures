//
//  VIPER-Router.swift
//  architectures
//
//  Created YutoMizutani on 2018/06/06.
//  Copyright © 2018 Yuto Mizutani. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

/*
 
 Router
     最後に、多分 VIPER Architecture で最も特有の要素はRouter です。
     それはモジュール間のナビゲーションロジックと、モジュール間がどうなるべきかを責務としています。
     （例: 画面に定義しているアニメーションを表示するか、どの様に2画面の間を遷移するべきか）
     まず、Presenterからどの画面をどのルートで表示するかのコマンドを受信します。
     Router も同様に データをある画面からそのほかへパスする責務を負います。Routerは 特定のモジュールで、protocolで定義しているナビゲーションの可能性がある全てを実装すべきものです。
     この情報をRouter protocol が唯一知っていることにより、アプリの全パスの概要を素早く得ることが可能なので、それはいいことです。
     iOS フレームワークの制限によりViewControllerは唯一画面間の遷移を実行できるため、 RouterはモジュールのControllerへの参照(リファレンス)か、その子クラスを含める必要があります。

 [iOS Project Architecture : Using VIPER [和訳]](https://qiita.com/YKEI_mrn/items/67735d8ebc9a83fffd29)より

 */

import UIKit

class VIPERRouter {

    weak var viewController: UIViewController?

    static func createModule() -> UIViewController {
        let view = VIPERViewController()
        let interactor = VIPERInteractor()
        let router = VIPERRouter()
        let presenter = VIPERPresenter(interface: view, interactor: interactor, router: router)

        view.presenter = presenter
        interactor.presenter = presenter
        router.viewController = view

        return view
    }
}

extension VIPERRouter: VIPERWireframeProtocol {
}
